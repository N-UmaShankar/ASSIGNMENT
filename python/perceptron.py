# -*- coding: utf-8 -*-
"""Perceptron.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15khcSpHO2uHk9J8Zma8tW7DB6P_QnGb3
"""

import numpy as np
import matplotlib.pyplot as plt
from tabulate import tabulate

x1 = np.array([[1], [-1], [0], [0.1], [0.2],[0.9]])
x2 = np.array([[1], [-1], [0.5], [0.5], [0.2], [0.5]])
print("*"*100)
print("\n GIVEN INPUT :  \n")
print("*"*100)
print("\n X1 : \n", x1)
print("\n X2 : \n", x2)

data = np.hstack((x1, x2)).tolist()
y = np.array([[1], [-1], [-1], [-1], [1], [1]])
print("\n class : \n", y)

data = np.hstack((x1, x2)).tolist()
final_data = np.hstack((data, y)).tolist()
headers = ["x1", "x2", "Class"]
tablefmt = "fancy_grid"
print("*"*100)
print("\n SAMPLE DATA :  \n")
print("*"*100)
print(tabulate(final_data, headers=headers, tablefmt=tablefmt))
print(np.mean(data,axis=0))
data = data - np.mean(data,axis=0)
final_data = np.hstack((data, y)).tolist()
print("*"*100)
print("\n MEAN SQUARED DATA :  \n")
print("*"*100)
print(tabulate(final_data, headers=headers, tablefmt=tablefmt))

# Create two arrays for the x and y coordinates of the points
x_coords = data[:,0]
y_coords = data[:,1]

y = y.ravel()
# Loop through the two classes
for i, class_label in enumerate(np.unique(y)):
    # Get the data points for the current class
    class_data = data[y == class_label]
    # Get the x and y coordinates for the current class
    class_x = class_data[:,0]
    class_y = class_data[:,1]
    # Plot the data points with different symbols and colors for each class
    if class_label == 1:
        plt.scatter(class_x, class_y, marker='+', color='green', label='Class  = +1')
    else:
        plt.scatter(class_x, class_y, marker='*', color='red', label='Class = -1')
# Set the axis labels and legend
plt.xlabel('x1')
plt.ylabel('x2')
plt.legend()
# Show the plot
plt.show()

def graph(data,w):
    # Create boolean mask for each class
    mask_plus = y.ravel() == 1
    mask_minus = y.ravel() == -1
    
    # Plot points for each class with different marker symbols and colors
    plt.scatter(data[mask_plus,0], data[mask_plus,1], marker='+', color='green', label='Class  = +1')
    plt.scatter(data[mask_minus,0], data[mask_minus,1], marker='*', color='red', label='Class = -1')
    
    # Plot decision boundary
    slope = -w[1] / w[2]
    intercept = -w[0] / w[2]
    x_vals = np.array([-1, 1])
    y_vals = intercept + slope * x_vals
    plt.plot(x_vals, y_vals, '--', color='black')
    
    # Set labels and legend
    plt.xlabel('x1')
    plt.ylabel('x2')
    plt.legend()
    
    # Show the plot
    plt.show()

correctClassified = 0
w = [1,1,1]
graph(data, w)

iteration = 0
while (correctClassified != len(data)): #Until everything is classified
    iteration += 1
    print("Iteration: ", iteration)

    for sample in range(len(data)):
        x = np.append(1, data[sample,0:2])
        print("*"*100)
        print("X : ",x)
        print("*"*100)

        if y[sample] == 1:
            print("W^TX =", np.dot(np.transpose(w), x))
            if np.dot(np.transpose(w), x) >= 0:
                correctClassified += 1
                print("\n","Classified Correctly","\n")
                print("The Weights are : ", w)
            else: #orange is classified as apple
                w = w + x
                print("\n","MisClassified", "\n")
                print("w = w + x", "\n")
                print("The Updated Weights are : ", w)
                graph(data, w)
                break

        else:
            print("W^TX =", np.dot(np.transpose(w), x))
            if np.dot(np.transpose(w), x) < 0:
                correctClassified += 1
                print("\n","Classified Correctly","\n")
                print("The Weights are : ", w)
            else:
                w = w - x
                print("\n","MisClassified", "\n")
                print("w = w - x", "\n")
                print("The Updated Weights are : ", w)
                graph(data, w)
                break

    if (correctClassified != len(data)):
        correctClassified = 0           

print("Final weights: ", w)